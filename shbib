#!/bin/sh

# Dependency: read, grep, curl, sort, exiftool, xclip/xsel/pbcopy,

# Variable explain:
# $y: the current argument
# $pos: the current position on argument y
# $y2: the current position on current screen position (invert color using SGR 33 7)
# $num: numbers of lines per argument
# $fin: bottom for printable area, depends on num
# $token: indicator for actions
# Dimension is adjustable by $top & $bottom


# Adjust tex template to your like
tex_template() {
    printf '%s\n' \
	'\documentclass[a4paper]{article}' \
	'% Beamer' \
	'% \documentclass{beamer}' \
	'% \usefonttheme[onlymath]{serif}' \
	'% \usetheme{metropolis}' \
	'' \
	'\usepackage[utf8]{inputenc}' \
	'\usepackage[T1]{fontenc}' \
	'\usepackage{textcomp}' \
	'\usepackage{amsmath, amssymb, amsthm}' \
	'\usepackage{import}' \
	'\usepackage{pdfpages}' \
	'\usepackage{transparent}' \
	'\usepackage{xcolor}' \
	'\newcommand{\inkfig}[2][1]{%' \
	'    \def\svgwidth{#1\columnwidth}' \
	'    \import{./figures/}{#2.pdf_tex}' \
	'}' \
	'\pdfsuppresswarningpagegroup=1' \
	"\\title{Note on \"$title\"}" \
	"\\author{Author(s): $author}" \
	'\date{\today}' \
	'\begin{document}' \
	'\maketitle' \
	'' \
	'' \
	'' \
	'\end{document}' > "$note"
}

# Stolen from shfm
# Reference: https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_sequences
esc() {
    case $1 in
        # vt100 (IL is vt102) (DECTCEM is vt520)
	CUP)     printf '%s[%s;%sH' "$esc_c" "$2" "$3" ;; # cursor to LINES($2), COLUMNS($3)
        CUU)     printf '%s[%sA'    "$esc_c" "$2"      ;; # cursor up
        CUD)     printf '%s[%sB'    "$esc_c" "$2"      ;; # cursor down
        CUR)     printf '%s[%sC'    "$esc_c" "$2"      ;; # cursor right
	CUL)     printf '%s[%sD'    "$esc_c" "$2"      ;; # cursor left
	DECAWM)  printf '%s[?7%s'   "$esc_c" "$2"      ;; # (h: set; l: unset) line wrap
        DECRC)   printf '%s8'       "$esc_c"           ;; # cursor restore
        DECSC)   printf '%s7'       "$esc_c"           ;; # cursor save
        DECSTBM) printf '%s[%s;%sr' "$esc_c" "$2" "$3" ;; # scroll region
	DECTCEM) printf '%s[?25%s'  "$esc_c" "$2"      ;; # (h: show; l: hide) cursor visible
	ED[0-2]) printf '%s[%sJ'    "$esc_c" "${1#ED}" ;; # clear screen
        EL[0-2]) printf '%s[%sK'    "$esc_c" "${1#EL}" ;; # clear line
        IL)      printf '%s[%sL'    "$esc_c" "$2"      ;; # insert line
        SGR)     printf '%s[%s;%sm' "$esc_c" "$2" "$3" ;; # colors

        # xterm (since 1988, supported widely)
	screen_alt) printf '%s[?1049%s' "$esc_c" "$2" ;; # (h: to; l: back from) alternate buffer
    esac
}

get_os() {
    case $OSTYPE in
	darwin*) BIB_OPENER=open; clipcopy=pbcopy ;;
	*) { command -v xclip 1> /dev/null 2>&1 && clipcopy=xclip; } || { command -v xsel 1> /dev/null 2>&1 && clipcopy=xsel; } ;;
    esac
}

term_setup() {
    num=$1; shift
    # space for status_line
    bottom=$((LINES - 2))
    top=3
    fin=$(( bottom - (bottom - (top - 1)) % num ))

    stty=$(stty -g)
    stty -icanon -echo
    esc screen_alt h
    esc DECAWM l
    esc DECTCEM l
    esc ED2
    esc DECSTBM "$top" "$fin"
}

term_resize() {
    # false-positive, behavior intentional, globbing is disabled.
    # shellcheck disable=2046
    {
        set -f -- $(stty size)
        set +f
    }

    LINES=$1 COLUMNS=$2
}

term_reset() {
    esc DECAWM h     >&2
    esc DECTCEM h    >&2
    esc ED2          >&2
    esc DECSTBM      >&2
    esc screen_alt l >&2
    stty "$stty"
}

redraw() {
    num=$1; shift
    list_print "$num" "$@"
    status_line 't'
    status_line 'b' "$#"
    # status_line 'b' "$y2 $pos $num $top $fin"
}

list_print() {
    num=$1; shift
    esc ED2
    esc CUP "$top"

    i=1
    pos=$(( num * y - num + top ))
    end=$(( fin + 1 ))
    mid=$(( end / 4 < 5 ? 1 : end / 4 ))

    case $hist in
        2) # redraw after cmd run
	    shift "$((pos >= y2 ? (pos - y2) / num : 0))"
        ;;

        1) # redraw after go-to-parent
            hist_search "$@"
            shift "$((y >= fin ? y - mid : 0))"
        ;;

        *) # everything else
	    shift "$((y >= (end - top) / num ? y - (end - top) / num : 0 ))"
        ;;
    esac

    for file do

	# same formula as $pos
	case $(( num * i - num + top )) in
	    $y2) esc SGR 33 7 ;;
	esac

	case $(( num * i - num + top - end )) in
	    -*)
		arg_format "$file"
		esc CUD
		;;
	esac
	i=$((i + 1))
    done

    esc CUP "$(( pos > y2 ? y2 : pos ))"
}

cur_assign(){ # assign $cur > 9
    shift "$1"
    cur=$1
}

arg_print() {
    offset=$1

    case $offset in
        "$y") esc SGR 33 7
    esac

    shift "$offset"

    case $offset in
        "$y") cur=$1
    esac

    arg_format "$1"
}

arg_format() { # token
    esc EL0
    case "$token" in
	's'|'c'|'o'|'n') printf %s "${1%$nl}" ;;
	'?') printf %s "$1" ;;
        ''|'S'|'b'|'B'|'R'|'r') printf %s "${1##*/}" ;;
	'q')
	    case "$token_q" in
	        ''|'S'|'sc'|'sg'|'so') printf %s "$1" ;;
		'b'|'B'|'Rc'|'Re') printf %s "${1%$nl}" ;;
	    esac
	    ;;
    esac
    esc SGR
    printf '\r'
}

status_line() {
    caption=$1; shift
    esc DECSC
    case "$caption" in
	't') esc CUP 1 ;;
	'b') esc CUP "$LINES" ;;
    esac

    case $USER in
        root) esc SGR 31 7 ;;
           *)
	       case "$caption" in
	           't') esc SGR 36 7 ;;
		   'b') esc SGR 34 7 ;;
	       esac
	       ;;
    esac

    case "$caption" in
        't')
	    printf '%*s\r' "$COLUMNS"
	    case $msg in
	        '') printf %s "Reference" ;;
		*) printf %s "$msg" ;;
	    esac
	    ;;
	'b')
	    printf '%*s\r%s ' "$COLUMNS" "" "($y/$1)"
	    case $ltype in
		'') printf %s "$BIB_PDF_PATH" ;;
		*) printf %s "$ltype" ;;
	    esac
    esac
    esc SGR
    esc DECRC
}

term_scroll_up() {
    num=$1; shift

    case $y in
        -*|0|1) return ;;
    esac

    y=$((y - 1)) pos=$(( num * y - num + top ))

    arg_print "$((y + 1))" "$@"

    case "$y2" in
	$top) [ $num -gt 1 ] && esc CUU $((num - 1)); esc IL "$num" ;;
	*) esc CUU "$((num * 2 - 1))"; y2=$(( y2 > top ? y2 - num : top )) ;;
    esac
    arg_print "$y" "$@"

    # Restore cursor to match y2
    [ $num -gt 1 ] && esc CUU "$((num - 1))"
    status_line 't'
    status_line 'b' "$#"
    # status_line 'b' "y2:$y2 pos:$pos num:$num top:$top fin:$fin" # DEBUG
}


term_scroll_down() {
    num=$1; shift

    case $((y - $#)) in
	[0-9]*) return
    esac

    y=$((y + 1))  pos=$(( num * y - num + top ))
    y2=$(( y2 + num < fin - (num - 1) ? y2 + num : fin - (num - 1) ))


    arg_print "$((y - 1))" "$@"
    printf '\n'
    arg_print "$y" "$@"

    [ $num -gt 1 ] && esc CUU "$((num - 1))"

    status_line 't'
    status_line 'b' "$#"
    # status_line 'b' "y2:$y2 pos:$pos num:$num top:$top fin:$fin" # DEBUG
}

term_page_up() {
    num=$1; shift
    move=$(((end - top) / (3 * num) > 2 ? (end - top) / (3 * num) : 2))

    case $y in
	-*|0|1) return ;;
    esac
    case $((y - 1 - move)) in
	-*|0) move=$((y - 1)) ;;
    esac
    y=$((y - move)) pos=$(( num * y - num + top ))

    for i in $(seq $((y + 1)) $((y + move))); do
	arg_print "$((y + move - i + y + 1))" "$@"
	case "$y2" in
	    $top) [ $num -gt 1 ] && esc CUU $((num - 1)); esc IL "$num" ;;
	    *) esc CUU "$((num * 2 - 1))"; y2=$(( y2 > top ? y2 - num : top )) ;;
	esac
    done
    arg_print "$y" "$@"

    # Restore cursor to match y2
    [ $num -gt 1 ] && esc CUU "$((num - 1))"
    status_line 't'
    status_line 'b' "$#"
    # status_line 'b' "y2:$y2 pos:$pos num:$num top:$top fin:$fin" # DEBUG
}

term_page_down() {
    num=$1; shift
    move=$(((end - top) / (3 * num) > 2 ? (end - top) / (3 * num) : 2))
    case $(( y - $# + move )) in
	[1-9]*) move=$(($# - y)) ;;
    esac
    y=$(( y + move ))
    pos=$(( num * y - num + top ))
    y2=$(( y2 + num * move < fin - (num - 1) ? y2 + num * move : fin - (num - 1) ))


    for i in $(seq $((y - move)) $((y - 1))); do
	arg_print "$i" "$@"
	printf '\n'
    done
    arg_print "$y" "$@"

    [ $num -gt 1 ] && esc CUU "$((num - 1))"

    status_line 't'
    status_line 'b' "$#"
    # status_line 'b' "y2:$y2 pos:$pos num:$num top:$top fin:$fin" # DEBUG
}

prompt() {
    esc DECSC
    esc CUP "$LINES"
    printf %s "$1"
    esc DECTCEM h
    esc EL0

    case $2 in
        r)
	    stty -cread icanon echo 1>/dev/null 2>&1
	    read -r ans ||:
	    stty -icanon -echo
	    ;;
    esac
    esc DECRC
    esc DECTCEM l
    status_line 'b' "($y/$#) $PWD"
}

cmd_run() {
    stty "$stty"
    esc DECTCEM h
    esc DECSTBM
    esc ED2
    esc DECAWM h
    "$@" ||:
    esc DECSTBM "$top" "$fin"
    esc DECTCEM l
    esc DECAWM l
    stty -icanon -echo
    hist=2
}


json_pretty_print() {
    unset tmplist
    IFS=','
    set -- $1
    unset IFS
    for line do
	# Define level of object
	while c=${line%%"${line##?}"}; do # %% is much efficient than %
	    nline=${line##?}
	    nc=${nline%%"${nline##?}"} # forward looking
	    case $c in
		'')
		    case $quote in
			0)
			    sv=$((lv * 2))
			    space="$(printf %${sv}s)" # space per lv*2
			    safe="$safe,${nl}$space" ;;
			10) safe="$safe," ;;
		    esac
		    break ;;
		'{'|'[')
		    lv=$((lv + 1)); sv=$((lv * 2))
		    case $nc in
			'}'|']')
			    safe="$safe$c"
			    ;;
		        *)
			    space="$(printf %${sv}s)" # space per lv*2
			    safe="$safe$c${nl}$space"
			    ;;
		    esac
		    ;;
		'}'|']')
		    lv=$((lv - 1)); sv=$((lv * 2))
		    case $nc in
		        '')
			    case $pre_c in
			        '{'|'[')
				    safe="$safe$c"
				    ;;
				*)
				    space="$(printf %${sv}s)" # space per lv*2
				    safe="$safe${nl}$space$c"
				    ;;
			    esac
			    ;;
			'}'|']')
			    space="$(printf %${sv}s)" # space per lv*2
			    safe="$safe${nl}$space$c"
			    ;;
			*)
			    space="$(printf %${sv}s)" # space per lv*2
			    safe="$safe$c${nl}$space"
			    ;;
		    esac
		    ;;
		'"')
		    quote=$(( quote > 5 ? 0 : 10 )) # with-in quote indicator
		    # safe=$safe$c # for formal formatting
		    ;;
		*)
		    safe=$safe$c
		    ;;
	    esac
	    line=${line##?}
	    pre_c=$c
	done
	tmplist="$tmplist$safe"
	unset safe
    done
    unset safe lv sv quote pre_c
}

json_match() {
    unset tmp2list
    IFS="$nl"
    set -- $1
    unset IFS
    for line do
	case $preline in
	    '        indexed'*) tmp2list="$tmp2list|" ;;
	    '        title'*) tmp2list="$tmp2list${nl}1Title: ${line##${line%%[![:space:]]*}}";;
	    '        container-title'*) tmp2list="$tmp2list${nl}4Journal: ${line##${line%%[![:space:]]*}}";;
	esac
	case $line in
	    '            given'*)
		tmp="${line##${line%%[![:space:]]*}}"
		tmp="${tmp##*:}"
		given="${tmp%%,*}"
		;;
	    '            family'*)
		tmp="${line##${line%%[![:space:]]*}}"
		tmp="${tmp##*:}"
		tmp="${tmp%%,*}"
		tmp2list="$tmp2list${nl}5Author(s): $given $tmp"
		;;
	    '        DOI'*)
		tmp="${line##${line%%[![:space:]]*}}"
		tmp="${tmp##*:}"
		tmp="${tmp%%,*}"
		tmp2list="$tmp2list${nl}6DOI: $tmp";;
	    '        type'*)
		tmp="${line##${line%%[![:space:]]*}}"
		tmp="${tmp##*:}"
		tmp="${tmp%%,*}"
		tmp2list="$tmp2list${nl}2Category: $tmp" ;;
	esac
	case $pre3line$pre2line in
	    '        published-print'*'          date-parts'*)
		tmp="${line##${line%%[![:space:]]*}}"
		tmp="${tmp##*:}"
		tmp="${tmp%%,*}"
		tmp2list="$tmp2list${nl}3Date: $tmp";;
	esac
	pre3line=$pre2line
	pre2line=$preline
	preline=$line
    done
}

ref_search() {
    tmplist= list=
    str=$ans url=
    while c=${str%"${str#?}"}; do
	case $c in
	    '') break ;;
	    [[:space:]]) url=$url\+ ;;
	    *)           url=$url$c ;;
	esac
	str=${str#?}
    done

    case "$url" in
        '') return 2 ;;
	*)
	    ltype="Searching..."
	    status_line 'b' "$#"
	    json=$(curl -s "https://api.crossref.org/works?query=$url")
	    case "$json" in
		*'Service Unavailable'*) return 1 ;;
		*)

		    json_pretty_print "$json" "$@"
		    json_match "$tmplist" "$@"

		    # Sort each field based on numbering
		    IFS='|'
		    set -- $tmp2list
		    unset IFS
		    for line do
			tmp3list="$tmp3list$(printf '%s' "$line" | sort -n)"
		    done

		    # Combining authors and Add '|' back to Title
		    IFS="$nl"
		    set -- $tmp3list
		    unset IFS
		    for line do
			case $line in
			    *'Author(s)'*)
				case $preline in
				    *'Author(s)'*) tmp4list="$tmp4list and ${line##*Author(s): }" ;;
				    *) tmp4list="$tmp4list${nl}${tab}${line#?}" ;;
				esac
				;;
			    *'Title'*) tmp4list="$tmp4list${nl}|${line#?}" ;;
			    *) tmp4list="$tmp4list${nl}${tab}${line#?}" ;;
			esac
			preline=$line
		    done

		    # Add \n if some entry does not have 6 lines
		    IFS='|'
		    set -- $tmp4list; shift
		    unset IFS

		    # Each item must have totally 6 \n
		    for line do
			case $line in
			    *${nl}*${nl}*${nl}*${nl}*${nl}*${nl}) list="$list|$line" ;;
			    *${nl}*${nl}*${nl}*${nl}*${nl}) list="$list|$line${nl}" ;;
			    *${nl}*${nl}*${nl}*${nl}) list="$list|$line${nl}${nl}" ;;
			    *${nl}*${nl}*${nl}) list="$list|$line${nl}${nl}${nl}" ;;
			    *${nl}*${nl}) list="$list|$line${nl}${nl}${nl}${nl}" ;;
			    *${nl}) list="$list|$line${nl}${nl}${nl}${nl}${nl}" ;;
			    *${nl}*${nl}*${nl}*${nl}*${nl}*) list="$list|$line${nl}" ;; # match last item
			    *${nl}*${nl}*${nl}*${nl}*) list="$list|$line${nl}${nl}" ;; # match last item
			    *${nl}*${nl}*${nl}*) list="$list|$line${nl}${nl}${nl}" ;; # match last item
			    *${nl}*${nl}*) list="$list|$line${nl}${nl}${nl}${nl}" ;; # match last item
			    *${nl}*) list="$list|$line${nl}${nl}${nl}${nl}${nl}" ;; # match last item
			esac
		    done
		    list=${list#*|}
		    unset tmplist tmp2list tmp3list tmp4list
		    ;;
	    esac
    esac
}

ref_gen() {
    tmplist= list=
    IFS="$nl"
    set -- $(cat -u $1)
    unset IFS
    case $# in
        0) list='no content' ;;
	*)
	    for line do
		case $line in
		    @*)
			tmp="${line##*\{}"
			tmplist="$tmplist${nl}|BibTeX: ${tmp%,}"
			;;
		    *[[:space:]]title*=*)
			tmp="${line#*\{}"
			tmplist="$tmplist${nl}${tab}Title: ${tmp%\}*}"
			;;
		    *[[:space:]]author*=*)
			tmp="${line#*\{}"
			tmplist="$tmplist${nl}${tab}Author(s): ${tmp%\}*}"
			;;
		    *[[:space:]]year*)
			tmp="${line#*=}"
			tmp="${tmp#\{}"
			tmp=${tmp%,}
			tmp=${tmp%\}}
			tmplist="$tmplist${nl}${tab}Year: $tmp"
			;;
		    *[[:space:]]journal*=*)
			tmp="${line#*\{}"
			tmplist="$tmplist${nl}${tab}Journal: ${tmp%\}*}"
			;;
		    *[[:space:]]doi*=*)
			tmp="${line#*\{}"
			tmplist="$tmplist${nl}${tab}Doi: ${tmp%\}*}"
		esac
	    done

	    IFS='|'
	    set -- $tmplist; shift
	    unset IFS

	    for line do
		case $line in
		    *${nl}*${nl}*${nl}*${nl}*${nl}*${nl}) list="$list|$line" ;;
		    *${nl}*${nl}*${nl}*${nl}*${nl}) list="$list|$line${nl}" ;;
		    *${nl}*${nl}*${nl}*${nl}) list="$list|$line${nl}${nl}" ;;
		    *${nl}*${nl}*${nl}) list="$list|$line${nl}${nl}${nl}" ;;
		    *${nl}*${nl}) list="$list|$line${nl}${nl}${nl}${nl}" ;;
		    *${nl}) list="$list|$line${nl}${nl}${nl}${nl}${nl}" ;;
		    *${nl}*${nl}*${nl}*${nl}*${nl}*) list="$list|$line${nl}" ;; # match last item
		    *${nl}*${nl}*${nl}*${nl}*) list="$list|$line${nl}${nl}" ;; # match last item
		    *${nl}*${nl}*${nl}*) list="$list|$line${nl}${nl}${nl}" ;; # match last item
		    *${nl}*${nl}*) list="$list|$line${nl}${nl}${nl}${nl}" ;; # match last item
		    *${nl}*) list="$list|$line${nl}${nl}${nl}${nl}${nl}" ;; # match last item
		esac
	    done
	    list=${list#*|}
		    ;;
    esac
}

entry_gen() {
    IFS="$nl"
    set -- $cur
    unset IFS
    for line do
	case $line in
	    BibTeX*) label="${line#*: }" ;;
	    *[[:space:]]Title*) title="${line#*: }" ;;
	    *[[:space:]]Author*) author="${line#*: }" ;;
	    *[[:space:]]Year*) year="${line#*: }" ;;
	    *[[:space:]]Journal*) journal="${line#*: }" ;;
	    *[[:space:]]Doi*) doi="${line#*: }" ;;
	esac
    done
}

restore() {
    unset faillist
    num=1 y=1 y2=$top cur=$1 ltype= msg= token=
    term_setup $num
    redraw $num "$@"
}

yesno() {
    msg=$1 item=$2 token_q=$3 shift 3
    num=1 y=1 y2=$top cur=$1 ltype= token=q
    redraw $num "$@"

    esc DECSC
    esc CUP $((top - 1 + 5))
    printf %s "$item"
    esc DECRC
}

filter() {
    IFS="$2" str="$3"
    set -- $1
    for line do
	tmp=${line##*$str}
	case $(( ${#line} - ${#tmp} )) in
	    0) shift ;;
	    *) filter="$filter$IFS$line" ;;
	esac
    done
    filt_out=${filter#*$IFS}
    unset IFS filter
}

waitclip() {
    unset bibtex clipcmd
    case "$clipcopy" in
	"pbcopy") clipcmd='pbpaste' ;;
	"xclip") clipcmd='xclip -o -selection clipboard'; printf '%s' "" | xclip -selection clipboard ;;
	"xsel") clipcmd='xsel -o --clipboard'; xsel -bc ;;
    esac
    count=1 countlimit=3600

    # Allow shell to read keypress and break the loop
    stty -icanon time 0 min 0

    while [ -z "$bibtex" ] && [ $count -le $countlimit ] && [ "$key" != h ]; do
	read key
	set -- "Copy BibTeX within $countlimit second; Already $count second past"
	num=1 y=1 y2=$top cur=$1 ltype="Copy BibTeX!" msg="Google Scholar Search"
	redraw 1 "$@"
	bibtex="$($clipcmd)"
	sleep 1; count=$((count + 1))
    done

    # restore stty sanity
    stty sane
    stty -icanon -echo
}

key() {
    while key=$(dd ibs=1 count=1 2>/dev/null); do
	case $key${esc:=0} in
	    "$ctrl_u"*)
		term_page_up $num "$@"
	    ;;

	    "$ctrl_f"*)
		term_page_down $num "$@"
	    ;;

	    k?|A2)
		term_scroll_up $num "$@"
	    ;;

            j?|B2)
		term_scroll_down $num "$@"
	    ;;

            l?|C2|"$esc") # ARROW RIGHT # token
		case "$token" in
		    'q')
			case "$cur" in
			    "Yes")
				case "$token_q" in
				    'sc')
					grep -q "${bibtex%%$nl*}" "$BIB"
					case $? in
					    0)
						set -- 'Reference already added; press h to leave'
						num=1 y=1 y2=$top cur=$1 ltype= msg="Result" token=?
						redraw $num "$@"
						;;
					    *)
						case "${bibtex%%$nl*}" in
						    @[[:alpha:]]*[[:alnum:]_],)
							printf '%s\n\n' "$bibtex" >> "$BIB"
							set -- 'Yes' \
							       'No'
							yesno "Reference added to $BIB; Download PDF file?" "" 'so' "$@"
							;;
						    *)
							set -- 'Not copying BibTeX; press h to leave'
							num=1 y=1 y2=$top cur=$1 ltype= msg="Result" token=?
							redraw $num "$@"
						esac
						;;
					esac
					;;
				    'so')
					IFS="$nl"
					set -- $bibtex
					for line do
					    case $line in
						*[[:space:]]url*=*) tmp="${line#*\{}"; url="${tmp%\}*}" ;;
					    esac
					done
					cmd_run "${BIB_OPENER:=${BROWSER:=xdg-open}}" "$url" 1>/dev/null &
					set -- "Open PDF file; press h to leave"
					num=1 y=1 y2=$top cur=$1 ltype= msg="Result" token=?
					redraw $num "$@"
					;;
				    'sg')
					cmd_run "${BIB_OPENER:=${BROWSER:=xdg-open}}" "https://scholar.google.com/scholar?&q=$ans" 1>/dev/null &
					waitclip "$@"
					set -- 'Yes' \
					       'No'
					case $bibtex in
					    '')
						set -- $BIB_PDF_PATH/*.pdf
						restore "$@"
						;;
					    *) yesno "Copy bibtex to $BIB?" "$bibtex" 'sc' "$@" ;;
					esac
					;;
				esac
				;;
			    "No")
				set -- $BIB_PDF_PATH/*.pdf
				restore "$@"
				;;
			    *)
				case "$token_q" in
				    'S')
					ans=${cur##* : }
					ans=${ans##*doi.org/}
					ans="${ans%%$nl*}"

					case "$ans" in
					    10\.[0-9][0-9][0-9][0-9]\/[[:alnum:].]*) # match doi
						bibtex=$(curl -s "http://api.crossref.org/works/$ans/transform/application/x-bibtex")
						set -- 'Yes' \
						       'No'
						yesno "Copy bibtex to $BIB?" "$bibtex" 'sc' "$@"
						;;
					    *)
						gscholar="There is no matching...\\(ㄒoㄒ)/${nl}${tab}Search in Google Scholar!${nl}${nl}${nl}${nl}${nl}"
						ref_search "$@"
						case $? in
						    1)
							set -- 'Yes' \
							      'No'
							yesno "Fail to connect Crossref. Search in Google scholar?" "" 'sg' "$@"
							;;
						    0)
							IFS='|'
							set -- $list \
							       $gscholar
							unset IFS
							num=6 y=1 y2=$top cur=$1 ltype="Search: $ans" msg="Search by text" token=s
							;;
						esac
						term_setup $num
						redraw $num "$@"
						;;
					esac
					;;
				    'b')
					entry_gen "$@"
					# Write journal to Description only if Description not exist
					exiftool -wm cg -Description="$journal" "$filename" -overwrite_original 1>/dev/null
					exiftool -Title="$title" -Author="$author" -doi="$doi" -filename="$label.pdf" "$filename" -overwrite_original 1>/dev/null
					case $? in
					    0) set -- "Successfully update database; press h to leave" ;;
					    *) set -- "Fail to update database; press h to leave" ;;
					esac
					num=1 y=1 y2=$top cur=$1 ltype= msg="Result" token=?
					redraw $num "$@"
					;;
				    'B')
					entry_gen "$@"
					exiftool -wm cg -Description="$journal" "$filename" -overwrite_original 1>/dev/null
					exiftool -Title="$title" -Author="$author" -doi="$doi" -filename="$label.pdf" "$filename" -overwrite_original 1>/dev/null
					case $? in
					    0) msg="Successfully update database!" ;;
					    *) msg="Fail to update database ㄒoㄒ" ;;
					esac
					faillist="${faillist#*"$filename"}${nl}${faillist%%"$filename"*}"
					IFS="$nl"
					set -- $faillist
					unset IFS
					num=1 y=1 y2=$top cur=$1 ltype="Building database, Automode!" token=B
					case $# in
					    0) set -- 'All PDF files in database is updated!'; token=? ;;
					esac
					redraw $num "$@"
					;;
				    'Rc')
					bibkey=${cur%%$nl*}
					bibkey=${bibkey##*BibTeX: }
					filter "$(cat -u "$BIB_LIB_PATH/$name.bib")" '@' "$bibkey"
					case $filt_out in
					    '')
						filter "$(cat -u $BIB)" '@' "$bibkey"
						printf '\n%s\n' "@$filt_out" >> "$BIB_LIB_PATH/$name.bib"
						msg_append="Add $bibkey; "
						;;
					    *)
						msg_append="$bibkey already added; "
						;;
					esac

					ref_gen "$BIB" "$@"

					IFS='|'
					set -- $list
					unset IFS
					num=6 y=1 y2=$top cur=$1 ltype="Create new sublibrary: $name.bib" msg="$msg_append Choose BibTeX entry to add: " token=q token_q=Rc
					term_setup $num
					redraw "$num" "$@"
					;;
				    'Re')
					case $cur in
					    $ADD)
						ref_gen "$BIB" "$@"

						IFS='|'
						set -- $list
						unset IFS
						num=6 y=1 y2=$top cur=$1 ltype="Edit existing sublibrary: $name.bib" msg="Choose BibTeX entry to add: " token=q token_q=Rc
						term_setup $num
						redraw "$num" "$@"
						;;
					    $RM)
						;;
					    *)
						ref_gen "$BIB_LIB_PATH/$name.bib" "$@"

						IFS='|'
						set -- $list
						unset IFS
						num=6 y=1 y2=$top cur=$1 ltype="$msg_append Edit existing sublibrary: $name.bib" msg="Choose BibTeX entry to delete: " token=q token_q=Re
						term_setup $num
						redraw "$num" "$@"

						bibkey=${cur%%$nl*}
						bibkey=${bibkey##*BibTeX: }
						msg_append="$bibkey deleted; "
						sublib=$(cat -u "$BIB_LIB_PATH/$name.bib")
						filter "$sublib" '@' "$bibkey"
						printf '%s' "${sublib%%@$filt_out*}${sublib##*@$filt_out}" > "$BIB_LIB_PATH/$name.bib"
						;;
					esac
					;;
				esac
				;;
			esac
			;;
		    's')
			case $cur in
			    "$gscholar")
				cmd_run "${BIB_OPENER:=${BROWSER:=xdg-open}}" "https://scholar.google.com/scholar?&q=$ans" 1>/dev/null &
				waitclip "$@"
				set -- 'Yes' \
				       'No'
				case $bibtex in
				    '')
					set -- $BIB_PDF_PATH/*.pdf
					restore "$@"
					;;
				    *) yesno "Copy bibtex to $BIB?" "$bibtex" 'sc' "$@" ;;
				esac
				;;
			    *)
				ans=${cur##*: }
				ans=${ans##*doi.org/}
				ans="${ans%%$nl*}"
				IFS='\'
				set -- $ans
				unset IFS
				for line do
				    safeans="$safeans$line"
				done

				bibtex=$(curl -s "http://api.crossref.org/works/$safeans/transform/application/x-bibtex")
				unset safeans

				set -- 'Yes' \
				       'No'
				yesno "Copy bibtex to $BIB?" "$bibtex" 'sc' "$@"
				;;
			esac
			;;
		    'c')
			bibkey=${cur%%$nl*}
			bibkey=${bibkey##*BibTeX: }
			case "$clipcopy" in
			    "pbcopy") printf '%s' "$bibkey" | pbcopy ;;
			    "xclip") printf '%s' "$bibkey" | xclip -selection clipboard ;;
			    "xsel") printf '%s' "$bibkey" | xsel --clipboard ;;
			esac
			set -- "$bibkey has copied to clipboard using $clipcopy; press h to leave"
			num=1 y=1 y2=$top cur=$1 ltype= msg="Result" token=
			redraw $num "$@"
			;;
		    'o')
			bibkey=${cur%%$nl*}
			bibkey=${bibkey##*BibTeX: }
			cmd_run "${BIB_OPENER:="${READER:=xdg-open}"}" "$BIB_PDF_PATH/$bibkey.pdf"
			redraw "$num" "$@"
			;;
		    'S')
			read -r type < "$cur"
			file=${cur##*/}
			basename=${file%%.*}
			case "$type" in
			    '%PDF'*) info=$(exiftool $cur) ;;
			    *) info='PDF file is broken, or not choosing PDF file; press h to leave' ;;
			esac
			IFS="$nl"
			set -- $info \
			       $basename
			unset IFS
			num=1 y=1 y2=$top cur=$1 ltype= msg='Search by which information?' token=q token_q=S
			redraw $num "$@"
			;;
		    'b'|'B')
			filename=$cur
			unset cur
			ref_gen "$BIB" "$@"

			IFS='|'
			set -- $list
			unset IFS
			case $token in
			    'b') token_q=b ;;
			    'B') token_q=B ;;
			esac
			num=6 y=1 y2=$top cur=$1 ltype="Build database" msg="Choose which BibTeX entry?" token=q
			case $# in
			    0)
				num=1
				set -- 'All PDF files in database is updated!'
				;;
			esac
			term_setup $num
			redraw "$num" "$@"
			;;
		    'R')
			case $cur in
			    $addlib)
				prompt "Name for new sublibrary: " r
				while c=${ans%"${ans#?}"}; do
				    case $c in
					'') break ;;
					[[:space:]]) name=$name\_ ;;
					*)           name=$name$c ;;
				    esac
				    ans=${ans#?}
				done
				[ -e "$BIB_LIB_PATH/$name.bib" ] || touch "$BIB_LIB_PATH/$name.bib"

				ref_gen "$BIB" "$@"

				IFS='|'
				set -- $list
				unset IFS
				num=6 y=1 y2=$top cur=$1 ltype="Create new sublibrary $name.bib" msg="Choose BibTeX entry to add:" token=q token_q=Rc
				term_setup $num
				redraw "$num" "$@"
				;;
			    *)
				name="${cur##*/}"
				name="${name%%.*}"
				ADD="Add new BibTeX entry to $name.bib"
				DEL="Delete existing BibTeX entry in $name.bib"
				RM="Remove sublibrary $name.bib"
				set -- "$ADD" \
				       "$DEL" \
				       "$RM"
				num=1 y=1 y2=$top cur=$1 ltype="Edit existing sublibrary $name.bib" msg="Add or Delete: " token=q token_q=Re
				term_setup $num
				redraw "$num" "$@"
				;;
			esac
			;;
		    'r')
			name="${cur##*/}"
			name="${name%%.*}"

			ref_gen "$BIB_LIB_PATH/$name.bib" "$@"

			IFS='|'
			set -- $list
			unset IFS
			num=6 y=1 y2=$top cur=$1 ltype="Open and view sublibrary: $name.bib" msg="Choose BibTeX entry to view: " token=o
			term_setup $num
			redraw "$num" "$@"
			;;
		    'n')
			ref=${cur##*BibTeX: }
			ref=${ref%%$nl*}
			note="$BIB_NOTE_PATH/$ref/$ref.tex"
			[ -w "$note" ] ||
			    {
				title=${cur##*Title: }
				title=${title%%$nl*}
				author=${cur##*Author(s): }
				author=${author%%$nl*}
				[ -d "$BIB_NOTE_PATH/$ref" ] || mkdir -p "$BIB_NOTE_PATH/$ref/"
				tex_template "$@"
			    }
			term_setup 1
			cmd_run "${BIB_OPENER:="${EDITOR:=vi}"}" "$note"
			redraw 1 "$@"
			num=6
			term_setup $num
			redraw "$num" "$@"
			;;
		    '')
			[ -e "$cur" ] &&
			    {
				cmd_run "${BIB_OPENER:="${READER:=xdg-open}"}" "$cur"
				redraw 1 "$@"
			    }
			;;
		    '?') ;;
		esac
            ;;

            h?|D2|"$bs_char"?) # ARROW LEFT
		set -- $BIB_PDF_PATH/*.pdf
		restore "$@"
            ;;

	    s?)
		gscholar="There is no matching...\\(ㄒoㄒ)/${nl}${tab}Search in Google Scholar!${nl}${nl}${nl}${nl}${nl}"
		prompt "Search in Crossref: " r
		ref_search "$@"
		case $? in
		    2) set -- 'type something'; num=1 cur=$1 ltype="Error!" msg="Error messege: " token= ;;
		    1)
			set -- 'Yes' \
			       'No'
			yesno "Fail to connect Crossref. Search in Google scholar?" "" 'sg' "$@"
			;;
		    0)
			IFS='|'
			set -- $list \
			       "$gscholar"
			unset IFS
			num=6 y=1 y2=$top cur=$1 ltype="search: $ans" msg="search by text" token=s
			;;
		esac
		term_setup $num
		redraw $num "$@"
	    ;;

	    S?)
		set -- $BIB_PDF_PATH/*.pdf
		num=1 y=1 y2=$top cur=$1 ltype= msg='Search by information in PDF' token=S
		redraw $num "$@"
	    ;;

	    o?)
		ref_gen "$BIB" "$@"

		IFS='|'
		set -- $list
		unset IFS
		num=6 y=1 y2=$top cur=$1 ltype="Open PDF file by $BIB" msg="Open PDF file by BibTeX entry" token=o
		term_setup $num
		redraw "$num" "$@"
	    ;;

	    c?)
		ref_gen "$BIB" "$@"

		IFS='|'
		set -- $list
		unset IFS
		num=6 y=1 y2=$top cur=$1 ltype="Copy BibTeX label" msg="Choose which BibTeX label?" token=c
		term_setup $num
		redraw "$num" "$@"
	    ;;

	    b?)
		set -- $BIB_PDF_PATH/*.pdf
		num=1 y=1 y2=$top cur=$1 ltype= msg='Choose PDF file to build database: ' token=b
		redraw $num "$@"
	    ;;

	    B?)
		set -- $BIB_PDF_PATH/*.pdf
		for pdf do
		    read -r type < "$pdf"
		    case "$type" in
		        '%PDF'*)
			    TMP="${pdf##*/}"; basename="${TMP%.*}"
			    grep '@' "$BIB" | grep -q "$basename"
			    case $? in
			        0) continue ;;
				*)
				    info=$(exiftool "$pdf")
				    tmp=${info##*Title                           : }
				    title=${tmp%%$nl*}
				    filter "$(cat -u $BIB)" '@' "$title"
				    case $filt_out in
				        '') faillist="$faillist${nl}$pdf" ;;
					*)
					    IFS="$nl"
					    set -- $filt_out
					    unset IFS
					    for line do
						case $line in
						    [[:alpha:]]*{[[:alnum:]_]*,) tmp="${line#*\{}"; label="${tmp%,}" ;;
						    *[[:space:]]title*=*) tmp="${line#*\{}"; title="${tmp%\}*}" ;;
						    *[[:space:]]author*=*) tmp="${line#*\{}"; author="${tmp%\}*}" ;;
						    *[[:space:]]journal*=*) tmp="${line#*\{}"; journal="${tmp%\}*}" ;;
						    *[[:space:]]doi*=*) tmp="${line#*\{}"; doi="${tmp%\}*}" ;;
						esac
						unset tmp
					    done
					    exiftool -wm cg -Description="$journal" "$pdf" -overwrite_original 1>/dev/null
					    exiftool -Title="$title" -Author="$author" -doi="$doi" -filename="$label.pdf" "$pdf" -overwrite_original 1>/dev/null
					    set -- "$label.pdf updated."
					    num=1 y=1 y2=$top cur=$1 ltype="Building database, Automode!" msg="Automode Result: "
					    redraw $num "$@"
					    ;;
				    esac
				    ;;
			    esac
			    ;;
		    esac
		done
		IFS="$nl"
		set -- $faillist
		unset IFS
		num=1 y=1 y2=$top cur=$1 ltype="Building database, Automode!" msg="Choose pdf to manually update metadata: " token=B
                case $# in
                    0) set -- 'All PDF files in database is updated!'; token=? ;;
                esac
                redraw $num "$@"
	    ;;

	    n?)
		BIB_NOTE_PATH="$BIB_PDF_PATH/Notes"
		[ -d "$BIB_NOTE_PATH" ] || mkdir -p "$BIB_NOTE_PATH"
		ref_gen "$BIB" "$@"

		IFS='|'
		set -- $list
		unset IFS
		num=6 y=1 y2=$top cur=$1 ltype="Write notes for BibTeX entry" msg="Choose BibTeX entry to write note on: " token=n
		term_setup $num
		redraw "$num" "$@"
	    ;;

	    R?)
		addlib='Create new sublibrary'
		BIB_LIB_PATH="$BIB_PDF_PATH/Libs"
		[ -d "$BIB_LIB_PATH" ] || mkdir -p "$BIB_LIB_PATH"

		set -- "$addlib" \
		       $BIB_LIB_PATH/*.bib
		num=1 y=1 y2=$top cur=$1 ltype="Create new sublibrary / Edit exsting sublibrary" msg="Choose sublibrary: " token=R
		term_setup $num
		redraw "$num" "$@"

	    ;;

	    r?)
		BIB_LIB_PATH="$BIB_PDF_PATH/Libs"
		set -- $BIB_LIB_PATH/*.bib
		num=1 y=1 y2=$top cur=$1 ltype="Open and view sublibrary" msg="Choose sublibrary: " token=r
		term_setup $num
		redraw "$num" "$@"
	    ;;

            g?)
                case $y in
                    1) continue ;;
                esac

                y=1 y2=$top cur=$1
		redraw "$num" "$@"
            ;;

            G?)
		y=$# pos=$(( num * y - num + top ))
		y2=$(( pos < fin - (num - 1) ? pos : fin - (num - 1) ))
		cur_assign "$y" "$@"
		redraw "$num" "$@"
            ;;

            /?) # token
                prompt / r

		case "$token" in
		    ''|'S')
			num=1
			filter "$BIB_PDF_PATH/*.pdf" "$nl" "$ans"
			IFS="$nl"
			set -- $filt_out
			unset IFS
			;;
		    's'|'c'|'o'|'n'|'b'|'B'|'r')
			filter "$list" '|' "$ans"
			IFS='|'
			set -- $filt_out
			unset IFS
			;;
		    'q')
			case "$token_q" in
			    'S'|'sc'|'sg'|'so')
				num=1
				filter "$info" "$nl" "$ans"
				IFS="$nl"
				set -- $filt_out
				unset IFS
				;;
			    'b'|'B'|'Rc'|'Re')
				filter "$list" '|' "$ans"
				IFS='|'
				set -- $filt_out
				unset IFS
				;;
			esac
			;;
		esac

                case $# in
                    0) num=1; set -- 'no result' ;;
                esac

		y=1 y2=$top cur=$1 ltype= msg="filter by *$ans*"
                redraw $num "$@"
            ;;

            \??)
                 set -- 'k/↑ - up' \
			'j/↓ - down' \
		        'l/→ - right' \
		        'h/← - left' \
			'Ctrl-f - PageDown' \
			'Ctrl-u - PageUp' \
                        'g - go to top' \
                        'G - go to bottom' \
			's - search online by text' \
			'S - search online by metadata in PDF file' \
			'c - copy BibTeX entry from your $BIB' \
			'o - open PDF file by BibTeX entry' \
			'b - manually build database by rename and encode metadata into PDF file' \
			'B - automatically build database by rename and encode metadata into PDF file' \
			'R - create new BibTeX entry sublibrary' \
			'r - open existing BibTeX entry sublibrary' \
			'n - write notes for BibTeX entry' \
                        '/ - search in $BIB_PDF_PATH/<input>*' \
                        '? - show keybinds'
                num=1 y=1 y2=$top cur=$1 ltype= msg=keybinds token='?'
                redraw $num "$@"
            ;;

            q?) exit 0 ;;
            "$esc_c"*) esc=1 ;;
                 '[1') esc=2 ;;
                    *) esc=0 ;;
	esac
    done
}

main() {
    esc_c=$(printf '\033')
    bs_char=$(printf '\177')
    ctrl_f=$(printf '\006')
    ctrl_u=$(printf '\025')
    tilda=$(printf '\176')

    set -- $BIB_PDF_PATH/*.pdf
    cur=$1 num=1
    term_resize
    term_setup $num

    trap 'term_reset'  EXIT INT
    trap 'term_resize; term_setup $num; y=1 y2=$top; redraw $num "$@"' WINCH

    y=1 y2=$top
    redraw $num "$@"

    get_os
    key "$@"
}

nl='
'
tab='	'
main "$@" >/dev/tty
