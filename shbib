#!/bin/sh

# Variable explain:
# $y: the current argument
# $pos: the current position on argument y
# $y2: the final position (invert color using SGR 33 7)
# $num: numbers of lines per argument
# $fin: bottom for printable area, depends on num
# $token: indicator for actions
# Dimension is adjustable by $top & $bottom


# Stolen from shfm
# Reference: https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_sequences
esc() {
    case $1 in
        # vt100 (IL is vt102) (DECTCEM is vt520)
	CUP)     printf '%s[%s;%sH' "$esc_c" "$2" "$3" ;; # cursor to LINES($2), COLUMNS($3)
        CUU)     printf '%s[%sA'    "$esc_c" "$2"      ;; # cursor up
        CUD)     printf '%s[%sB'    "$esc_c" "$2"      ;; # cursor down
        CUR)     printf '%s[%sC'    "$esc_c" "$2"      ;; # cursor right
	CUL)     printf '%s[%sD'    "$esc_c" "$2"      ;; # cursor left
	DECAWM)  printf '%s[?7%s'   "$esc_c" "$2"      ;; # (h: set; l: unset) line wrap
        DECRC)   printf '%s8'       "$esc_c"           ;; # cursor restore
        DECSC)   printf '%s7'       "$esc_c"           ;; # cursor save
        DECSTBM) printf '%s[%s;%sr' "$esc_c" "$2" "$3" ;; # scroll region
	DECTCEM) printf '%s[?25%s'  "$esc_c" "$2"      ;; # (h: show; l: hide) cursor visible
	ED[0-2]) printf '%s[%sJ'    "$esc_c" "${1#ED}" ;; # clear screen
        EL[0-2]) printf '%s[%sK'    "$esc_c" "${1#EL}" ;; # clear line
        IL)      printf '%s[%sL'    "$esc_c" "$2"      ;; # insert line
        SGR)     printf '%s[%s;%sm' "$esc_c" "$2" "$3" ;; # colors

        # xterm (since 1988, supported widely)
	screen_alt) printf '%s[?1049%s' "$esc_c" "$2" ;; # (h: to; l: back from) alternate buffer
    esac
}

term_setup() {
    num=$1; shift
    # space for status_line
    bottom=$((LINES - 2))
    top=3
    fin=$(( bottom - (bottom - (top - 1)) % num ))

    stty=$(stty -g)
    stty -icanon -echo
    esc screen_alt h
    esc DECAWM l
    esc DECTCEM l
    esc ED2
    esc DECSTBM "$top" "$fin"
}

term_resize() {
    # false-positive, behavior intentional, globbing is disabled.
    # shellcheck disable=2046
    {
        set -f -- $(stty size)
        set +f
    }

    LINES=$1 COLUMNS=$2
}

term_reset() {
    esc DECAWM h     >&2
    esc DECTCEM h    >&2
    esc ED2          >&2
    esc DECSTBM      >&2
    esc screen_alt l >&2
    stty "$stty"
}

redraw() {
    num=$1; shift
    list_print "$num" "$@"
    status_line 't'
    status_line 'b' "$#"
}

list_print() {
    num=$1; shift
    esc ED2
    esc CUP "$top"

    i=1
    pos=$(( num * y - (num - 1) + (top - 1) ))
    end=$(( fin + 1 ))
    mid=$(( end / 4 < 5 ? 1 : end / 4 ))
    case $hist in
        2) # redraw after cmd run
            shift "$((y > y2 ? y - y2 : 0))"
        ;;

        1) # redraw after go-to-parent
            hist_search "$@"
            shift "$((y >= fin ? y - mid : 0))"
        ;;

        *) # everything else
	    shift "$((y >= (end - 1) / num ? y - (end - 1) / num : 0 ))"
        ;;
    esac

    for file do

	# same formula as $pos
	case $(( num * i - (num - 1) + (top - 1) )) in
	    $y2) esc SGR 33 7 ;;
	esac

	case $(( num * i - (num - 1) + (top - 1) - end )) in
	    -*)
		arg_format "$file"
		esc CUD
		;;
	esac
	i=$((i + 1))
    done

    esc CUP "$(( pos > y2 ? y2 : pos ))"
}

arg_print() {
    offset=$1

    case $offset in
        "$y") esc SGR 33 7
    esac

    shift "$offset"

    case $offset in
        "$y") cur=$1
    esac

    arg_format "$1"
}

arg_format() {
    esc EL0
    case "$token" in
	's') printf %s "${1%$nl}" ;;
	'?'|'q') printf %s "$1" ;;
        ''|'p') printf %s "${1##*/}" ;;
    esac
    esc SGR
    printf '\r'
}

status_line() {
    caption=$1; shift
    esc DECSC
    case "$caption" in
	't') esc CUP 1 ;;
	'b') esc CUP "$LINES" ;;
    esac

    case $USER in
        root) esc SGR 31 7 ;;
           *)
	       case "$caption" in
	           't') esc SGR 36 7 ;;
		   'b') esc SGR 34 7 ;;
	       esac
	       ;;
    esac

    case "$caption" in
        't')
	    printf '%*s\r' "$COLUMNS"
	    case $msg in
	        '') printf %s "Reference" ;;
		*) printf %s "$msg" ;;
	    esac
	    ;;
	'b')
	    printf '%*s\r%s ' "$COLUMNS" "" "($y/$1)"
	    case $ltype in
		'') printf %s "$BIB_PDF_PATH" ;;
		*) printf %s "$ltype" ;;
	    esac
    esac
    esc SGR
    esc DECRC
}

term_scroll_up() {
    num=$1; shift

    case $y in
        -*|0|1) return ;;
    esac

    y=$((y - 1))

    arg_print "$((y + 1))" "$@"

    case "$y2" in
	$top) [ $num -gt 1 ] && esc CUU $((num - 1)); esc IL "$num" ;;
	*) esc CUU "$((num * 2 - 1))"; y2=$(( y2 > top ? y2 - num : top )) ;;
    esac
    arg_print "$y" "$@"

    # Restore cursor to match y2
    [ $num -gt 1 ] && esc CUU "$((num - 1))"
    status_line 't'
    status_line 'b' "$#"
}


term_scroll_down() {
    num=$1; shift

    case $((y - $#)) in
	[0-9]*) return
    esac

    y=$((y + 1))  pos=$(( num * y - (num - 1) + (top - 1) ))
    y2=$(( pos < fin ? pos : fin - (num - 1) ))

    arg_print "$((y - 1))" "$@"
    printf '\n'
    arg_print "$y" "$@"

    [ $num -gt 1 ] && esc CUU "$((num - 1))"

    status_line 't'
    status_line 'b' "$#"
}

prompt() {
    esc DECSC
    esc CUP "$LINES"
    printf %s "$1"
    esc DECTCEM h
    esc EL0

    case $2 in
        r)
            stty icanon echo
            read -r ans ||:
            stty -icanon -echo
        ;;
    esac

    esc DECRC
    esc DECTCEM l
    status_line 'b' "($y/$#) $PWD"
}

cmd_run() {
    stty "$stty"
    esc DECTCEM h
    esc DECSTBM
    esc ED2
    "$@" ||:
    esc DECSTBM "$top" "$((LINES - 2))"
    esc DECTCEM l
    stty -icanon -echo
    hist=2
}

ref_search() {
    str=$ans
    url=
    while c=${str%"${str#?}"}; do
	case $c in
	    '') break ;;
	    [[:space:]]) url=$url\+ ;;
	    *)           url=$url$c ;;
	esac

	str=${str#?}
    done

    case "$url" in
        '') return 2 ;;
	*)
	    ltype="Searching..."
	    status_line 'b' "$#"
	    html="$(curl -s "https://search.crossref.org/?q=$url")"
	    case "$html" in
		*'Service Unavailable'*) return 1 ;;
		*)
		    TMP="${html##*<table>}"
		    TMP2="${TMP%%</table>*}"
		    list=$(printf '%s' "$TMP2" |
			sed "s/<p class='lead'>/@/g; s/<[^>]*>//g; /^$/ d" |
			awk 'BEGIN {
			    RS="@";
			}
			{
			    n=split($0, sp, /\n/)
			    title = sp[2]
			    category = sp[3]
			    for (i=1; i in sp; i++) {
				if (match(sp[i], /^[0-9][0-9][0-9][0-9]$/))
				    year = sp[i]
				else if (match(sp[i], /Authors:.*/))
				    author = sp[i]
				else if (match(sp[i-1], /^in$/))
				    journal = sp[i]
				else if (match(sp[i], /(https:\/\/)?10\.[0-9][0-9][0-9][0-9][0-9.]*\/[^[:space:]]*/))
				    doi = sp[i]
			    }
			    print "|", "Title: " title, "\n\tCategory: " category, "\n\tJournal: " journal, "\n\tYear: " year, "\n\tAuthor: " author, "\n\tDoi: " doi
			}')
		    list=${list#|}
		    ;;
	    esac
    esac
}

restore() {
    num=1 y=1 y2=$top cur=$1 ltype= msg= token=
    term_setup $num
    redraw $num "$@"
}

yesno() {
    msg=$1; shift
    item=$1; shift
    token_q=$1; shift
    num=1 y=1 y2=$top cur=$1 ltype= token=q
    redraw $num "$@"

    esc DECSC
    esc CUP $((top - 1 + 5))
    printf %s "$item"
    esc DECRC
}

key() {
    while key=$(dd ibs=1 count=1 2>/dev/null); do
	case $key${esc:=0} in
	    k?|A2)
		case "$token" in
		    's') num=6 ;;
		    ''|'?'|'q'|'p') num=1 ;;
		esac
		term_scroll_up $num "$@"
		;;
            j?|B2)
		case "$token" in
		    's') num=6 ;;
		    ''|'?'|'q'|'p') num=1 ;;
		esac
		term_scroll_down $num "$@"
		status_line 'b' "$cur"
		;;
            l?|C2|"$esc") # ARROW RIGHT
		case "$token" in
		    'q')
			case "$cur" in
			    "Yes")
				case "$token_q" in
				    's')
					grep "${bibtex%%$nl*}" "$BIB"
					case $? in
					    0)
						set -- 'Reference already added; press h to leave'
						num=1 y=1 y2=$top cur=$1 ltype= msg="Result" token=
						redraw $num "$@"
						;;
					    *)
						printf '%s\n\n' "$bibtex" >> "$BIB"
						set -- "Reference added to $BIB; press h to leave"
						num=1 y=1 y2=$top cur=$1 ltype= msg="Result" token=
						redraw $num "$@"
						;;
					esac
					;;
				esac
				;;
			    "No")
				set -- $BIB_PDF_PATH/*.pdf
				restore "$@"
				# num=1 y=1 y2=$top cur=$1 ltype= msg= token=
				# term_setup $num
				# redraw $num "$@"
				;;
			    *)
				case "$token_q" in
				    'p')
					ans=${cur##*: }
					ans=${ans##*doi.org/}
					ans="${ans%$nl*}"
					case "$ans" in
					    10\.[0-9][0-9][0-9][0-9]\/[^[:space:][:cntrl:]]*) # match doi
						bibtex=$(curl -s "http://api.crossref.org/works/$ans/transform/application/x-bibtex")
						set -- 'Yes' \
						       'No'
						yesno "Copy bibtex to $BIB?" "$bibtex" 's' "$@"
						# num=1 y=1 y2=$top cur=$1 ltype= msg="Copy bibtex to $BIB?" token=q token_q=s
						# redraw $num "$@"

						# esc DECSC
						# esc CUP $((top - 1 + 5))
						# printf %s "$bibtex"
						# esc DECRC
						;;
					    *)
						ref_search "$@"
						case $? in
						    1) set -- 'Fail to connect to Crossref'; num=1 token= ;;
						    0)
							IFS='|'
							set -- $list; shift
							unset IFS
							num=6 y=1 y2=$top cur=$1 ltype="Search: $ans" msg="Search by text" token=s
							;;
						esac
						term_setup $num
						redraw $num "$@"
						;;
					esac
					;;
				esac
				;;
			esac
			;;
		    's')
			ans=${cur##*: }
			ans=${ans##*doi.org/}
			ans="${ans%$nl*}"
			bibtex=$(curl -s "http://api.crossref.org/works/$ans/transform/application/x-bibtex")

			set -- 'Yes' \
			       'No'
			yesno "Copy bibtex to $BIB?" "$bibtex" 's' "$@"
			# num=1 y=1 y2=$top cur=$1 ltype= msg="Copy bibtex to $BIB?" token=q token_q=s
			# redraw $num "$@"

			# esc DECSC
			# esc CUP $((top - 1 + 5))
			# printf %s "$bibtex"
			# esc DECRC
			;;
		    'p')

			case "$(dd if="$1" count=4 bs=1)" in
			    '%PDF') info=$(exiftool $cur) ;;
			    *) info='PDF file is broken, or not choosing PDF file; press h to leave' ;;
			esac
			IFS="$nl"
			set -- $info
			unset IFS
			num=1 y=1 y2=$top cur=$1 ltype= msg='Search by information in PDF' token=q token_q=p
			redraw $num "$@"
			;;
		    '')
			[ -e "$cur" ] &&
			    {
				cmd_run "${BIB_OPENER:="${READER:=xdg-open}"}" "$cur"
				redraw 1 "$@"
			    }
			;;
		    '?') ;;
		esac
            ;;
            h?|D2|"$bs_char"?) # ARROW LEFT
		set -- $BIB_PDF_PATH/*.pdf
		restore "$@"
            ;;
	    s?)
		prompt "Search in Crossref: " r
		# ref_search "$@"
		list=$(cat -u /home/huijunchen/Testing/output)
		case $? in
		    2) set -- 'type something'; num=1 token= ;;
		    1) set -- 'fail to connect to crossref'; num=1 token= ;;
		    0)
			IFS='|'
			set -- $list; shift
			unset IFS
			num=6 y=1 y2=$top cur=$1 ltype="search: $ans" msg="search by text" token=s
			;;
		esac
		term_setup $num
		redraw $num "$@"
	    ;;

	    p?)
		set -- $BIB_PDF_PATH/*.pdf
		num=1 y=1 y2=$top cur=$1 ltype= msg='Search by information in PDF' token=p
		redraw $num "$@"
	    ;;

            g?)
                case $y in
                    1) continue ;;
                esac

		case "$token" in
		    's') num=6 ;;
		    ''|'?'|'q'|'p') num=1 ;;
		esac
                y=1 y2=$top cur=$1
		redraw "$num" "$@"
            ;;

            G?)
		case "$token" in
		    's') num=6 ;;
		    ''|'?'|'q'|'p') num=1 ;;
		esac
		y=$# cur=$# pos=$(( num * y - (num - 1) + (top - 1) ))
		y2=$(( pos < fin - (num - 1) ? pos : fin - (num - 1) ))
		redraw "$num" "$@"
            ;;
            /?)
                prompt / r

                set -- $BIB_PDF_PATH/$ans*.pdf

                case $1$# in
                    "$ans*1") set -- 'no results'
                esac

		num=1 y=1 y2=$top cur=$1 ltype= msg="search $BIB_PDF_PATH/$ans*"
                redraw $num "$@"
            ;;
            \??)
		token='?' num=1
                 set -- 'k - up' \
			'j - down' \
		        'l - right' \
		        'h - left' \
                        'g - go to top' \
                        'G - go to bottom' \
			's - search reference on Crossref by text' \
			'p - search reference on Crossref by PDF file' \
                        '/ - search in $BIB_PDF_PATH/<input>*' \
                        '? - show keybinds'

                y=1 y2=$top cur=$1 ltype= msg=keybinds
                redraw $num "$@"
            ;;
            q?) exit 0 ;;
	esac
    done
}

main() {
    esc_c=$(printf '\033')
    bs_char=$(printf '\177')

    set -- $BIB_PDF_PATH/*.pdf
    cur=$1

    term_resize
    term_setup 1

    trap 'term_reset'  EXIT INT
    trap 'term_resize; term_setup $num; y=1 y2=$top; redraw $num "$@"' WINCH

    y=1 y2=$top
    redraw 1 "$@"

    key "$@"
}

nl='
'
tab='	'
main "$@" >/dev/tty
