#!/bin/sh

# Stolen from shfm
esc() {
    case $1 in
        # vt100 (IL is vt102) (DECTCEM is vt520)
	CUP)     printf '%s[%s;%sH' "$esc_c" "$2" "$3" ;; # cursor to LINES($2), COLUMNS($3)
        CUU)     printf '%s[%sA'    "$esc_c" "$2"      ;; # cursor up
        CUD)     printf '%s[%sB'    "$esc_c" "$2"      ;; # cursor down
        CUR)     printf '%s[%sC'    "$esc_c" "$2"      ;; # cursor right
	CUL)     printf '%s[%sD'    "$esc_c" "$2"      ;; # cursor left
	DECAWM)  printf '%s[?7%s'   "$esc_c" "$2"      ;; # (h: set; l: unset) line wrap
        DECRC)   printf '%s8'       "$esc_c"           ;; # cursor restore
        DECSC)   printf '%s7'       "$esc_c"           ;; # cursor save
        DECSTBM) printf '%s[%s;%sr' "$esc_c" "$2" "$3" ;; # scroll region
	DECTCEM) printf '%s[?25%s'  "$esc_c" "$2"      ;; # (h: show; l: hide) cursor visible
        ED[0-2]) printf '%s[%sJ'    "$esc_c" "${1#ED}" ;; # clear screen
        EL[0-2]) printf '%s[%sK'    "$esc_c" "${1#EL}" ;; # clear line
        IL)      printf '%s[%sL'    "$esc_c" "$2"      ;; # insert line
        SGR)     printf '%s[%s;%sm' "$esc_c" "$2" "$3" ;; # colors

        # xterm (since 1988, supported widely)
	screen_alt) printf '%s[?1049%s' "$esc_c" "$2" ;; # (h: to; l: back from) alternate buffer
    esac
}

term_setup() {
    num=$1; shift
    stty=$(stty -g)
    stty -icanon -echo
    esc screen_alt h
    esc DECAWM l
    esc DECTCEM l
    esc ED2
    esc DECSTBM 1 "$((bottom - bottom % num))"
}

term_resize() {
    # false-positive, behavior intentional, globbing is disabled.
    # shellcheck disable=2046
    {
        set -f -- $(stty size)
        set +f
    }

    LINES=$1 COLUMNS=$2

    # space for status_line
    bottom=$((LINES - 2))
}

term_reset() {
    esc DECAWM h     >&2
    esc DECTCEM h    >&2
    esc ED2          >&2
    esc DECSTBM      >&2
    esc screen_alt l >&2
    stty "$stty"
}

redraw() {
    num=$1; shift
    list_print "$num" "$@"
    status_line "$#"
}

list_print() {
    num=$1; shift
    esc ED2
    esc CUP

    i=1
    # end=$((bottom + 1))
    end=$((bottom - bottom % num + 1))
    mid=$((bottom / 4 < 5 ? 1 : bottom / 4))

    case $hist in
        2) # redraw after cmd run
            shift "$((y > y2 ? y - y2 : 0))"
        ;;

        1) # redraw after go-to-parent
            hist_search "$@"
            shift "$((y >= bottom ? y - mid : 0))"
        ;;

        *) # everything else
	    shift "$((y >= bottom / num ? y - bottom / num : 0 ))"
        ;;
    esac

    for file do
	case $(( num * i - (num - 1) )) in
	    "$y2") esc SGR 0 7
	esac

	case $(( num * i - (num - 1) - end )) in
	    -*)
		case "$token" in
		    's') para_format "$file" ;;
		    '') line_format "$file" ;;
		esac
		esc CUD
		;;
	esac
	i=$((i + 1))
    done

    esc CUP "$(( num * y - (num - 1) > y2 ? y2 : num * y - (num - 1) ))"
}

arg_print() {
    offset=$1

    case $offset in
        "$y") esc SGR 0 7
    esac

    shift "$offset"

    case $offset in
        "$y") cur=$1
    esac

    case "$token" in
        's') para_format "$1" ;;
	'') line_format "$1" ;;
    esac
}

line_format() {
    esc EL0
    printf %s "${1##*/}"
    esc SGR
    printf '\r'
}

para_format() {
    esc EL0
    printf %s "${1%$nl}"
    esc SGR
    printf '\r'
}

status_line() {
    esc DECSC
    esc CUP "$LINES"

    case $USER in
        root) esc SGR 31 7 ;;
           *) esc SGR 34 7 ;;
    esac

    printf '%*s\r%s ' "$COLUMNS" "" "($y/$1)"

    case $ltype in
        '') printf %s "$BIB_PDF_PATH" ;;
         *) printf %s "$ltype"
    esac

    esc SGR
    esc DECRC
}

term_scroll_up() {
    num=$1; shift

    case $y in
        -*|0|1) return ;;
    esac

    y=$((y - 1))

    [ $num -gt 1 ] && [ $y2 -ne $(( bottom - bottom % num - (num - 1) )) ] && esc CUU "$((num - 1))"
    arg_print "$((y + 1))" "$@"

    case "$(( (y2 + num - 1) / num ))" in
	1) [ $num -gt 1 ] && esc CUU "$(( num * 2 - 1 ))"; esc IL "$num" ;;
	*) esc CUU "$(( num * 2 - 1 ))"; y2=$(( (y2 + num - 1) / num > 1 ? y2 - num : 1 )) ;;
    esac

    arg_print "$y" "$@"
    status_line "$#"
}


term_scroll_down() {
    num=$1; shift

    case $((y - $#)) in
	[0-9]*) return
    esac

    y=$((y + 1))
    y2=$(( $num * y - ($num - 1) < bottom - bottom % $num ? $num * y - ($num - 1) : bottom - bottom % $num ))

    [ $num -gt 1 ] && esc CUU "$((num - 1))"

    arg_print "$((y - 1))" "$@"
    printf '\n'
    arg_print "$y" "$@"
    status_line "$#"
}

prompt() {
    esc DECSC
    esc CUP "$LINES"
    printf %s "$1"
    esc DECTCEM h
    esc EL0

    case $2 in
        r)
            stty icanon echo
            read -r ans ||:
            stty -icanon -echo
        ;;
    esac

    esc DECRC
    esc DECTCEM l
    status_line "($y/$#) $PWD"
}

cmd_run() {
    stty "$stty"
    esc DECTCEM h
    esc DECSTBM
    esc ED2
    "$@" ||:
    esc DECSTBM 1 "$((LINES - 2))"
    esc DECTCEM l
    stty -icanon -echo
    hist=2
}

ref_search() {
    token=s
    url=
    while c=${ans%"${ans#?}"}; do
	case $c in
	    '') break ;;
	    [[:space:]]) url=$url\+ ;;
	    *)           url=$url$c ;;
	esac

	ans=${ans#?}
    done

    case "$url" in
        '') return 2 ;;
	*)
	ltype="Searching..."
	status_line "$#"
	html="$(curl -s "https://search.crossref.org/?q=$url")"
	case "$html" in
	    *'Service Unavailable'*) return 1 ;;
	    *)
		TMP="${html##*<table>}"
		TMP2="${TMP%%</table>*}"
		list=$(printf '%s' "$TMP2" |
		    sed "s/<p class='lead'>/@/g; s/<[^>]*>//g; /^$/ d" |
		    awk 'BEGIN {
			RS="@";
		    }
		    {
			n=split($0, sp, /\n/)
			title = sp[2]
			category = sp[3]
			for (i=1; i in sp; i++) {
			    if (match(sp[i], /^[0-9][0-9][0-9][0-9]$/))
				year = sp[i]
			    else if (match(sp[i], /Authors:.*/))
				author = sp[i]
			    else if (match(sp[i-1], /^in$/))
				journal = sp[i]
			    else if (match(sp[i], /(https:\/\/)?10\.[0-9][0-9][0-9][0-9][0-9.]*\/[^[:space:]]*/))
				doi = sp[i]
			}
			print "|", "Title: " title, "\n\tCategory: " category, "\n\tJournal: " journal, "\n\tYear: " year, "\n\tAuthor: " author, "\n\tDOI: " doi
		    }')
		list=${list#|}
		;;
	esac
    esac
}

main() {
    # set -e
    esc_c=$(printf '\033')
    bs_char=$(printf '\177')

    set -- $BIB_PDF_PATH/*.pdf
    cur=$1

    term_resize
    term_setup 1

    trap 'term_reset'  EXIT INT
    trap 'term_resize; term_setup 1; y=1 y2=1; redraw 1 "$@"' WINCH

    y=1 y2=1
    redraw 1 "$@"

    while key=$(dd ibs=1 count=1 2>/dev/null); do
        case $key${esc:=0} in
            k?|A2)
		case "$token" in
		    's') term_scroll_up 6 "$@" ;;
		    '') term_scroll_up 1 "$@" ;;
		esac
		;;
            j?|B2)
		case "$token" in
		    's') term_scroll_down 6 "$@" ;;
		    '') term_scroll_down 1 "$@" ;;
		esac
		;;
            l?|C2|"$esc") # ARROW RIGHT
		case "$token" in
		    's')
			unset token
			doi=${cur##*DOI: }

			# set scroll area back
			term_setup 1
			set -- $BIB_PDF_PATH/*.pdf
			y=1 y2=1 cur=$1 ltype=
			redraw 1 "$@"
			;;
		    '')
			cmd_run "${BIB_OPENER:="${READER:=xdg-open}"}" "$cur"
			redraw 1 "$@"
			;;
		esac
            ;;
            h?|D2|"$bs_char"?) # ARROW LEFT
		case $ltype in
		    *) ltype= ;;
		esac
		case "$token" in
		    's')
			unset token

			# set scroll area back
			term_setup 1
			set -- $BIB_PDF_PATH/*.pdf
			y=1 y2=1 cur=$1
			redraw 1 "$@"
			;;
		esac
            ;;
	    s?)
		prompt "Search in Crossref: " r
		ref_search "$@"
		# list=$(cat -u $HOME/Testing/output)
		case $? in
		    2)
			set -- 'Type something'
			y=1 y2=1 cur=$1 ltype=
			redraw 1 "$@"
			;;
		    1)
			set -- 'Fail to connect to Crossref'
			y=1 y2=1 cur=$1 ltype=
			redraw 1 "$@"
			;;
		    0)
			# set scroll area to modulo of 6
			term_setup 6
			IFS="|"
			set -- $list; shift
			y=1 y2=1 cur=$1 ltype="Result"
			redraw 6 "$@"
			;;
		esac

	    ;;
            g?)
                case $y in
                    1) continue
                esac

                y=1 y2=1 cur=$1
		case "$token" in
		    's') redraw 6 "$@" ;;
		    '') redraw 1 "$@" ;;
		esac
            ;;

            G?)
		case "$token" in
		    's') num=6 ;;
		    '') num=1 ;;
		esac
		y=$#
		y2=$(( num * $# - (num - 1) < bottom - bottom % num - (num - 1) ? num * $# - (num - 1) : bottom - bottom % num - (num - 1) ))
		redraw "$num" "$@"
		# case "$token" in
		#     's')
		# 	y=$#
		# 	y2=$(( 6 * $# - 5 < bottom - bottom % 6 ? 6 * $# - 5 : bottom - bottom % 6 ))
		# 	redraw 6 "$@"
		# 	;;
		#     '') y=$#
		# 	y2=$(($# < bottom ? $# : bottom))
		# 	redraw 1 "$@"
		# 	;;
		# esac
            ;;
            /?)
                prompt / r

                # word splitting and globbing intentional
                # shellcheck disable=2086
                set -- $BIB_PDF_PATH/$ans*.pdf

                case $1$# in
                    "$ans*1") set -- 'no results'
                esac

                y=1 y2=1 cur=$1 ltype="search $BIB_PDF_PATH/$ans*"
                redraw 1 "$@"
            ;;
            \??)
                 set -- 'k - up' \
			'j - down' \
		        'l - right' \
		        'h - left' \
                        'g - go to top' \
                        'G - go to bottom' \
			's - search reference on Crossref' \
                        '/ - search in $BIB_PDF_PATH/<input>*' \
                        '? - show keybinds'

                y=1 y2=1 cur=$1 ltype=keybinds
                redraw 1 "$@"
                status_line "$#"
            ;;
            q?) exit 0 ;;
	esac
    done
}

nl='
'
tab='	'
main "$@" >/dev/tty
